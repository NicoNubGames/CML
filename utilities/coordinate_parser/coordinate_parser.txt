#include <iostream>
#include <vector>
#include <array>
#include <algorithm>

struct block
{
	int x, y, z, yaw, pitch;

	block(int x, int y, int z, int yaw, int pitch) : x(x), y(y), z(z), yaw(yaw), pitch(pitch) {};

	void rotate() // Rotate clockwise, i.e. N -> E -> S -> W
	{
		int swap = x;
		x = -z;
		z = swap;

		yaw += 90;

		if (yaw >= 540)
		{
			yaw -= 360;
		}
	}
    
    // Two blocks are the same if they occupy the same space
    bool operator==(const block &o)
    {
        return x == o.x && y == o.y && z == o.z;
    }
};

int getIndexOfDirection(std::string s)
{
	int index = 0;

	if (s == "N")
	{
		index = 0;
	}
	else if (s == "E")
	{
		index = 1;
	}
	else if (s == "S")
	{
		index = 2;
	}
	else if (s == "W")
	{
		index = 3;
	}

	return index;
}

int main()
{
	std::string dir;
    std::cin >> dir;
    
    std::vector<block> original_blocks;
    
    int x, y, z, yaw, pitch;
    while (std::cin >> x >> y >> z >> yaw >> pitch)
    {
        original_blocks.emplace_back(x, y, z, yaw, pitch);
    }
    
    // Generate a set of unique neighbor blocks, for use in checking if neighboring blocks
    // are certain values.  This is super-expensive to do in macromod, so we precalculate it here
    
    // Algorithm for computing neighbors is N^2, could be N*lg(N) if we use a set instead, but C++ is fast anyway
    
    std::vector<block> neighbor_list;
    
    for (unsigned int i = 0; i < original_blocks.size(); i++)
    {
        const auto &b = original_blocks[i];
        
        std::vector<block> local_neighbors;
        
        auto left = b;
        left.x++;
        local_neighbors.push_back(left);
        
        auto right = b;
        right.x--;
        local_neighbors.push_back(right);
        
        auto up = b;
        up.y++;
        local_neighbors.push_back(up);
        
        auto down = b;
        down.y--;
        local_neighbors.push_back(down);
        
        auto forward = b;
        forward.z++;
        local_neighbors.push_back(forward);
        
        auto backward = b;
        backward.z--;
        local_neighbors.push_back(backward);
        
        // If any of the local neighbors are not part of original_blocks or 
        // neighbor_list, add them to neighbor_list
        
        for (unsigned int j = 0; j < local_neighbors.size(); j++)
        {
            auto &maybe_neighbor = local_neighbors[j];
            
            // If maybe_neighbor isn't a member of either list, add it to neighbor_list
            if (std::find(original_blocks.begin(), original_blocks.end(), maybe_neighbor) == original_blocks.end() &&
                std::find(neighbor_list.begin(), neighbor_list.end(), maybe_neighbor) == neighbor_list.end())
            {
                neighbor_list.push_back(maybe_neighbor);
            }
        }
    }
    
    // Save bounds for when we write to top of generated script (So that user can loop through blocks, neighbors, etc.
    unsigned int block_end = original_blocks.size() - 1;
    unsigned int neighbor_begin = original_blocks.size();
    unsigned int neighbor_end = original_blocks.size() + neighbor_list.size() - 1;
    
    // Push all members of neighbor list onto original blocks while setting yaw and pitch to 0
    for (unsigned int i = 0; i < neighbor_list.size(); i++)
    {
        auto &n = neighbor_list[i];
        n.yaw = 0;
        n.pitch = 0;
        
        original_blocks.push_back(n);
    }
    
	// Create space for four block vectors
	std::array<std::vector<block>, 4> cardinals;

	// Copy original block vector to beginning element of cardinal array
	cardinals[0] = original_blocks;

	for (unsigned int i = 1; i < cardinals.size(); i++)
	{
		// Copy previous cardinal to current
		cardinals[i] = cardinals[i - 1];

		// For each block in current cardinal, rotate.
		for (unsigned int j = 0; j < cardinals[i].size(); j++)
		{
			block &b = cardinals[i][j];
			b.rotate();
		}
	}
    
	int north_index = 4 - getIndexOfDirection(dir);

	std::vector<std::string> if_statements;
	if_statements.push_back("IF(%DIRECTION% = \"N\")");
	if_statements.push_back("ELSEIF(%DIRECTION% = \"E\")");
	if_statements.push_back("ELSEIF(%DIRECTION% = \"S\")");
	if_statements.push_back("ELSEIF(%DIRECTION% = \"W\")");
    
	std::string tab = "    ";
    
    // Output number of blocks, so we can easily loop through
    
    std::cout << "// Generated by coordinate_parser.cpp, the automated block positioning system" << std::endl;
    
    std::cout << "#block_end = " << block_end << std::endl;
    std::cout << "#neighbor_begin = " << neighbor_begin << std::endl;
    std::cout << "#neighbor_end = " << neighbor_end << std::endl;

	for (unsigned int i = 0; i < 4; i++)
	{
		north_index %= 4;
		std::vector<block> set = cardinals[north_index];

		std::cout << if_statements[i] << std::endl;;

		for (unsigned int j = 0; j < set.size(); j++)
		{
			block b = set[j];
			std::string sign;

			sign = b.x < 0 ? "-" : "+";
			std::cout << tab << "#block_x[" << j << "] = (%XPOS% " << sign << " " << abs(b.x) << ")" << std::endl;
			sign = b.y < 0 ? "-" : "+";
			std::cout << tab << "#block_y[" << j << "] = (%YPOS% " << sign << " " << abs(b.y) << ")" << std::endl;
			sign = b.z < 0 ? "-" : "+";
			std::cout << tab << "#block_z[" << j << "] = (%ZPOS% " << sign << " " << abs(b.z) << ")" << std::endl;
			
			std::cout << tab << "#block_yaw[" << j << "] = " << b.yaw << std::endl;
			std::cout << tab << "#block_pitch[" << j << "] = " << b.pitch << std::endl;

			if (j != set.size() - 1)
			{
				std::cout << std::endl;
			}
		}

		north_index++;
	}

	std::cout << "ENDIF" << std::flush;
    
    return 0;
}